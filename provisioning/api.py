"""
FastAPI application for provisioning API.

Provides endpoints for the mobile app to provision headless Pi Zero nodes.
"""

import json
import os
import platform
import signal
import threading
import uuid
from pathlib import Path
from typing import Callable, Optional

from fastapi import FastAPI, BackgroundTasks
from fastapi.responses import Response, PlainTextResponse

from provisioning.models import (
    K2ProvisionRequest,
    K2ProvisionResponse,
    NetworkInfo,
    NodeInfo,
    ProvisioningState,
    ProvisionRequest,
    ProvisionResponse,
    ProvisionStatus,
    ScanNetworksResponse,
)
from provisioning.registration import register_with_command_center
from provisioning.startup import is_provisioned, mark_provisioned
from utils.encryption_utils import save_k2
from provisioning.state_machine import ProvisioningStateMachine
from provisioning.wifi_credentials import save_wifi_credentials
from provisioning.wifi_manager import WiFiManager


# Version of the provisioning firmware
FIRMWARE_VERSION = "1.0.0"


def _get_mac_address() -> str:
    """Get the MAC address of the primary network interface."""
    try:
        # Try to get MAC from /sys/class/net on Linux
        for iface in ["wlan0", "eth0", "en0"]:
            path = Path(f"/sys/class/net/{iface}/address")
            if path.exists():
                return path.read_text().strip()
    except (OSError, IOError):
        pass

    # Fallback: generate a consistent ID from UUID
    return f"00:00:{uuid.getnode():012x}"[-17:].replace(":", ":")


def _get_hardware_type() -> str:
    """Determine the hardware type."""
    machine = platform.machine().lower()
    system = platform.system().lower()

    if "arm" in machine and system == "linux":
        # Check for Pi Zero specifically
        try:
            with open("/proc/device-tree/model") as f:
                model = f.read().lower()
                if "zero" in model:
                    return "pi-zero-w"
                elif "raspberry" in model:
                    return "raspberry-pi"
        except (OSError, IOError):
            pass
        return "arm-linux"

    if system == "darwin":
        return "macos"

    return f"{system}-{machine}"


def _get_node_id() -> str:
    """
    Get or generate the node ID.

    Tries to read from config.json first, otherwise generates from MAC.
    """
    config_path = os.environ.get("CONFIG_PATH")
    if config_path:
        try:
            with open(config_path) as f:
                config = json.load(f)
                if "node_id" in config:
                    return config["node_id"]
        except (FileNotFoundError, json.JSONDecodeError):
            pass

    # Generate from MAC address
    mac = _get_mac_address().replace(":", "")[-8:]
    return f"jarvis-{mac}"


def _get_capabilities() -> list[str]:
    """Get node capabilities."""
    # Basic capabilities - could be extended with hardware detection
    return ["voice", "speaker"]


def _save_node_credentials(node_id: str, node_key: str) -> bool:
    """
    Save node credentials (node_id and node_key) to config.json.

    These credentials are returned by command center during registration
    and are required for all authenticated API calls.

    Args:
        node_id: The node ID
        node_key: The node's API key (generated by jarvis-auth)

    Returns:
        True if credentials were saved successfully
    """
    config_path = os.environ.get("CONFIG_PATH")
    if not config_path:
        return False

    try:
        config: dict = {}
        try:
            with open(config_path) as f:
                config = json.load(f)
        except FileNotFoundError:
            pass

        config["node_id"] = node_id
        config["api_key"] = node_key

        with open(config_path, "w") as f:
            json.dump(config, f, indent=2)

        return True
    except (OSError, IOError, json.JSONDecodeError):
        return False


def _update_config(room: str, command_center_url: str) -> bool:
    """
    Update the config.json with provisioning data.

    Args:
        room: Room name for the node
        command_center_url: URL of the command center

    Returns:
        True if config was updated successfully
    """
    config_path = os.environ.get("CONFIG_PATH")
    if not config_path:
        return False

    try:
        # Load existing config or create new
        config: dict = {}
        try:
            with open(config_path) as f:
                config = json.load(f)
        except FileNotFoundError:
            pass

        # Update with provisioning data
        config["room"] = room
        config["jarvis_command_center_api_url"] = command_center_url

        # Write back
        with open(config_path, "w") as f:
            json.dump(config, f, indent=2)

        return True
    except (OSError, IOError, json.JSONDecodeError):
        return False


def create_provisioning_app(
    wifi_manager: WiFiManager,
    on_provisioned: Optional[Callable[[], None]] = None
) -> FastAPI:
    """
    Create the FastAPI provisioning application.

    Args:
        wifi_manager: WiFi manager implementation (real or simulated)
        on_provisioned: Optional callback when provisioning completes successfully.
                       Used for auto-shutdown when running from main.py.

    Returns:
        FastAPI application instance
    """
    app = FastAPI(
        title="Jarvis Node Provisioning",
        description="API for provisioning headless Jarvis nodes",
        version=FIRMWARE_VERSION
    )

    state_machine = ProvisioningStateMachine()
    _provisioning_lock = threading.Lock()
    _on_provisioned = on_provisioned

    # Captive portal endpoints - trick iOS/Android into thinking there's internet
    # Without these, iOS may disconnect from the node's AP
    @app.get("/generate_204")
    async def generate_204() -> Response:
        """Android captive portal check."""
        return Response(status_code=204)

    @app.get("/hotspot-detect.html")
    async def hotspot_detect() -> PlainTextResponse:
        """Apple captive portal check."""
        return PlainTextResponse("<HTML><HEAD><TITLE>Success</TITLE></HEAD><BODY>Success</BODY></HTML>")

    @app.get("/library/test/success.html")
    async def apple_success() -> PlainTextResponse:
        """Apple captive portal check (alternate)."""
        return PlainTextResponse("<HTML><HEAD><TITLE>Success</TITLE></HEAD><BODY>Success</BODY></HTML>")

    @app.get("/success.txt")
    async def success_txt() -> PlainTextResponse:
        """Generic captive portal check."""
        return PlainTextResponse("success")

    @app.get("/api/v1/info", response_model=NodeInfo)
    async def get_info() -> NodeInfo:
        """Get node information and current state."""
        return NodeInfo(
            node_id=_get_node_id(),
            firmware_version=FIRMWARE_VERSION,
            hardware=_get_hardware_type(),
            mac_address=_get_mac_address(),
            capabilities=_get_capabilities(),
            state=state_machine.state
        )

    @app.get("/api/v1/scan-networks", response_model=ScanNetworksResponse)
    async def scan_networks() -> ScanNetworksResponse:
        """Scan for available WiFi networks."""
        networks = wifi_manager.scan_networks()
        return ScanNetworksResponse(networks=networks)

    @app.post("/api/v1/provision", response_model=ProvisionResponse)
    async def provision(
        request: ProvisionRequest,
        background_tasks: BackgroundTasks
    ) -> ProvisionResponse:
        """
        Receive WiFi credentials and begin provisioning.

        This endpoint accepts credentials and returns immediately.
        The actual provisioning happens in the background.
        Poll GET /api/v1/status for progress.
        """
        # Only allow one provisioning at a time
        if not _provisioning_lock.acquire(blocking=False):
            return ProvisionResponse(
                success=False,
                message="Provisioning already in progress"
            )

        def do_provisioning() -> None:
            try:
                _run_provisioning(
                    wifi_manager=wifi_manager,
                    state_machine=state_machine,
                    ssid=request.wifi_ssid,
                    password=request.wifi_password,
                    room=request.room,
                    command_center_url=request.command_center_url,
                    household_id=request.household_id,
                    admin_key=request.admin_key,
                    on_provisioned=_on_provisioned
                )
            finally:
                _provisioning_lock.release()

        background_tasks.add_task(do_provisioning)

        return ProvisionResponse(
            success=True,
            message="Credentials received. Attempting connection..."
        )

    @app.get("/api/v1/status", response_model=ProvisionStatus)
    async def get_status() -> ProvisionStatus:
        """Get current provisioning status."""
        status = state_machine.get_status()
        return ProvisionStatus(**status)

    @app.post("/api/v1/provision/k2", response_model=K2ProvisionResponse)
    async def provision_k2(request: K2ProvisionRequest) -> K2ProvisionResponse:
        """
        Accept K2 encryption key from mobile app during provisioning.

        K2 is used for end-to-end encryption of node settings during backup/sync.
        This endpoint is only available during pairing mode (AP_MODE).
        """
        # Check if in pairing mode (AP_MODE)
        if state_machine.state != ProvisioningState.AP_MODE:
            # Also reject if already provisioned
            if is_provisioned():
                return K2ProvisionResponse(
                    success=False,
                    error="Node is already provisioned. Re-enter pairing mode to update K2."
                )
            # If in CONNECTING/REGISTERING/ERROR state, still allow K2
            # as these are intermediate states during provisioning

        # Validate node_id matches this node
        actual_node_id = _get_node_id()
        if request.node_id != actual_node_id:
            return K2ProvisionResponse(
                success=False,
                error=f"Node ID mismatch: expected {actual_node_id}, got {request.node_id}"
            )

        # Save K2 encrypted with K1
        try:
            save_k2(request.k2, request.kid, request.created_at)
        except ValueError as e:
            return K2ProvisionResponse(
                success=False,
                error=str(e)
            )
        except FileNotFoundError as e:
            return K2ProvisionResponse(
                success=False,
                error=f"Encryption key (K1) not found: {e}"
            )

        return K2ProvisionResponse(
            success=True,
            node_id=request.node_id,
            kid=request.kid
        )

    return app


def _run_provisioning(
    wifi_manager: WiFiManager,
    state_machine: ProvisioningStateMachine,
    ssid: str,
    password: str,
    room: str,
    command_center_url: str,
    household_id: str,
    admin_key: Optional[str] = None,
    on_provisioned: Optional[Callable[[], None]] = None
) -> None:
    """
    Run the full provisioning flow.

    This runs in a background thread.

    Args:
        wifi_manager: WiFi manager for network operations
        state_machine: State machine for tracking progress
        ssid: WiFi network SSID
        password: WiFi network password
        room: Room name for this node
        command_center_url: URL of the command center
        household_id: UUID of the household this node belongs to
        admin_key: Admin API key for command center (for registration)
        on_provisioned: Optional callback when provisioning completes successfully
    """
    try:
        # Step 1: Save credentials
        state_machine.transition_to(
            ProvisioningState.CONNECTING,
            f"Saving credentials for {ssid}...",
            progress=10
        )
        save_wifi_credentials(ssid, password)

        # Step 2: Connect to WiFi
        state_machine.transition_to(
            ProvisioningState.CONNECTING,
            f"Connecting to {ssid}...",
            progress=30
        )

        # Stop AP mode if running (real Pi only)
        wifi_manager.stop_ap_mode()

        if not wifi_manager.connect(ssid, password):
            state_machine.set_error(f"Failed to connect to {ssid}")
            return

        state_machine.transition_to(
            ProvisioningState.CONNECTING,
            f"Connected to {ssid}",
            progress=50
        )

        # Step 3: Update config
        state_machine.transition_to(
            ProvisioningState.REGISTERING,
            "Updating configuration...",
            progress=60
        )

        if not _update_config(room, command_center_url):
            state_machine.set_error("Failed to update configuration")
            return

        # Step 4: Register with command center
        state_machine.transition_to(
            ProvisioningState.REGISTERING,
            "Registering with command center...",
            progress=70
        )

        node_id = _get_node_id()

        # Register via command center (which forwards to jarvis-auth)
        # This is the single gateway pattern - all registrations go through CC
        if admin_key:
            result = register_with_command_center(
                command_center_url=command_center_url,
                node_id=node_id,
                room=room,
                household_id=household_id,
                admin_key=admin_key
            )

            if result:
                # Save the returned node_key to config
                node_key = result.get("node_key")
                if node_key:
                    _save_node_credentials(node_id, node_key)
            else:
                # Registration failure is not fatal for now
                # The node may already exist, or admin_key may be invalid
                pass

        state_machine.transition_to(
            ProvisioningState.REGISTERING,
            "Finalizing...",
            progress=90
        )

        # Step 5: Mark as provisioned
        mark_provisioned()

        state_machine.transition_to(
            ProvisioningState.PROVISIONED,
            "Provisioning complete! You can now start the main Jarvis service.",
            progress=100
        )

        # Call the completion callback (e.g., to trigger server shutdown)
        if on_provisioned:
            # Small delay to allow status response to be returned
            import time
            time.sleep(1)
            on_provisioned()

    except Exception as e:
        state_machine.set_error(str(e))
